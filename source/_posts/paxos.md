---
title: paxos
date: 2017-03-04 18:48:26
tags:
---

约定：
没有约束时，acceptor均应同意写入请求。
请求如果成功均有返回值，如果返回超时认为请求失败
只要读到一个写入值，就认为没有写入的必要

写成功指超过一半返回

理想情况：
一个requester。请求写入有两种结果：超过一半server返回ok，或者少于一半返回ok。无论哪种情况都把最近一次写入请求的值v缓存起来。第一种情况下已经达成consensus，后续读直接返回该值，没有后续写；第二种情况下instance处于unknown，后续读引发对v的重写，后续写可以执行且更新v值。

礼貌情况：
多个requester，互相礼貌即没有并发。这时缓存方法失效，写入请求要知道是否之前有写入，从server读并期望超过一半返回。如果少于一半直接失败，否则，如果所有返回都是空值则发起写入请求，否则失败。如果写入不成功则instance是unknown。

读请求依赖于一个与写入值关联的递增的id。读请求期望超过一半回复，少于一半则失败，否则对于最大且非空的id关联的值执行一次写入，如果成功返回该值，失败返回unknown。

无并发的假设很强，这里的id对于保证instance的状态没有作用，仅仅确保consensus后读到的值一致。

并发情况：
requester之间存在并发。难点在于写入请求的两阶段都会乱序。
请求i的一阶段和请求j的一阶段
请求i的二阶段和请求j的二阶段
请求i的一阶段和请求j的二阶段

可以推出并发下需要满足的不变式。请求i写入超过一半的一刻，i是写入server的最大的请求id。因为反之后续读请求可能读到id大于i的值（读后会执行一次写入，因为id大所以会成功，覆盖consensus的值）。满足这一不变式的解决方法是，在写请求的一阶段公布自己的id，server收到后如果大于存储的最大id则更新。在第二阶段，如果收到的id小于最大id，server不会写入。下面证明i写入超过一半的一刻是最大的id。假设请求j>i，对于i写入的超过一半的那些server，j只能在此之后才能对它们进行第一阶段，否则i无法成功写入。j的返回必然报告i被写入，于是请求j失败。

